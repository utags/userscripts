import {
  addValueChangeListener,
  getValue,
  setValue,
} from 'browser-extension-storage'

import { debounce } from '../../utils/async'

type SettingsSnapshot = {
  enabled: boolean
  checkUnreadNotifications: boolean
  checkUnreadNotificationsTitle: boolean
  checkUnreadNotificationsFavicon: boolean
  checkUnreadNotificationsUtags: boolean
}

type GetSettings = () => SettingsSnapshot

const CHECK_INTERVAL = 30 * 1000
const LOCK_TIMEOUT = 20 * 1000
const KEY_LOCK = 'check_lock'
const KEY_LAST_CHECK = 'last_check'
const KEY_UNREAD_COUNT = 'unread_count'

export async function setUnreadCount(count: number): Promise<void> {
  return setValue(KEY_UNREAD_COUNT, count)
}

let initialized = false
let currentUnreadCount = 0
let utagsHostObserver: MutationObserver | undefined
let utagsShadowObserver: MutationObserver | undefined

function startUtagsObserver(getSettings: GetSettings): void {
  // Observer for Shadow Root changes
  const onShadowMutation: MutationCallback = (mutations) => {
    let shouldUpdate = false
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        shouldUpdate = true
        break
      }
    }

    if (shouldUpdate) {
      updateUtagsShortcuts(currentUnreadCount, getSettings)
    }
  }

  // Observer for Document changes (to detect Host element)
  const onDocumentMutation: MutationCallback = (mutations) => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (
          node instanceof HTMLElement &&
          node.dataset.ushortcutsHost === 'utags-shortcuts'
        ) {
          observeShadowRoot(node)
          updateUtagsShortcuts(currentUnreadCount, getSettings)
        }
      }
    }
  }

  // Function to attach observer to Shadow Root
  function observeShadowRoot(host: HTMLElement): void {
    if (utagsShadowObserver) utagsShadowObserver.disconnect()
    if (!host.shadowRoot) return

    utagsShadowObserver = new MutationObserver(onShadowMutation)
    utagsShadowObserver.observe(host.shadowRoot, {
      childList: true,
      subtree: true,
    })
  }

  // Check if host already exists
  const host = document.querySelector<HTMLElement>(
    '[data-ushortcuts-host="utags-shortcuts"]'
  )
  if (host) {
    observeShadowRoot(host)
  }

  // Start observing document for new host elements
  utagsHostObserver = new MutationObserver(onDocumentMutation)
  utagsHostObserver.observe(document.documentElement, {
    childList: true,
    subtree: true,
  })
}

type ApiResponse = {
  c: number
  m: string
  d?: {
    unread_count: number
    badge_unread_count: number
  }
  t: number
}

async function fetchUnreadCount(): Promise<number | undefined> {
  try {
    const res = await fetch('https://2libra.com/api/notifications/unread-count')
    const json = (await res.json()) as ApiResponse
    if (json.c === 0 && json.d) {
      return json.d.unread_count
    }
  } catch (error) {
    console.error('[2libra-plus] Failed to fetch unread count', error)
  }

  return undefined
}

let originalFavicon: string | undefined
let lastGeneratedFavicon: string | undefined
let faviconObserver: MutationObserver | undefined

function updateFavicon(count: number): void {
  const links = Array.from(
    document.querySelectorAll<HTMLLinkElement>('link[rel~="icon"]')
  )

  // Detect new original favicon from fresh links (not generated by us)
  const freshLinks = links.filter(
    (l) =>
      l.href !== lastGeneratedFavicon &&
      l.dataset.count === undefined &&
      l.getAttribute('href') // Ensure it has an href
  )

  if (freshLinks.length > 0) {
    // Use the last one as it's likely the intended one by the site
    originalFavicon = freshLinks[freshLinks.length - 1].href
  } else if (originalFavicon === undefined) {
    // Initialize if not set
    originalFavicon = '/favicon.ico'
  }

  let link = links[0]

  // Remove other icon links to prevent conflicts
  if (links.length > 1) {
    for (let i = 1; i < links.length; i++) {
      const l = links[i]
      l.removeAttribute('href')
      l.removeAttribute('rel')
      delete l.dataset.count

      // 不能删除元素，否则会导致下面代码处 js 报错。
      // Uncaught TypeError: Cannot read properties of null (reading 'removeChild')
      // (t = t.stateNode).parentNode.removeChild(t);
      // 改为删除 href 属性
      // l.remove() // Safe to remove in modern browsers if not iterating live NodeList
    }
  }

  if (!link) {
    link = document.createElement('link')
    link.rel = 'icon'
    document.head.append(link)
  }

  // If count is 0, restore original
  if (count === 0) {
    if (link.href !== originalFavicon) {
      link.href = originalFavicon!
      link.dataset.count = '' // Clear count
      lastGeneratedFavicon = undefined // Reset generated
    }

    return
  }

  // If count > 0, check if we need to update
  // If the link is already showing what we want, skip
  if (
    link.dataset.count === count.toString() &&
    link.href === lastGeneratedFavicon
  ) {
    return
  }

  link.type = 'image/png'
  link.dataset.count = count.toString()

  const canvas = document.createElement('canvas')
  canvas.width = 32
  canvas.height = 32
  const ctx = canvas.getContext('2d')
  if (!ctx) return

  const img = new Image()
  img.crossOrigin = 'anonymous'
  img.addEventListener('load', () => {
    ctx.clearRect(0, 0, 32, 32)
    ctx.drawImage(img, 0, 0, 32, 32)

    // Draw red circle
    ctx.beginPath()
    ctx.arc(22, 22, 10, 0, 2 * Math.PI)
    ctx.fillStyle = '#ff0000'
    ctx.fill()

    // Draw text
    const text = count > 99 ? '99+' : count.toString()
    ctx.font = count > 99 ? 'bold 12px sans-serif' : 'bold 16px sans-serif'
    ctx.fillStyle = '#ffffff'
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    ctx.fillText(text, 22, 23)

    if (link) {
      const dataUrl = canvas.toDataURL('image/png')
      // Check again to prevent loop if something changed during load
      if (link.href === dataUrl) return

      lastGeneratedFavicon = dataUrl
      link.href = dataUrl
      // Force update favicon by re-appending (some browsers need this)
      // But re-appending triggers childList mutation.
      // Since we check lastGeneratedFavicon, it should be fine.
      if (link.parentNode === document.head) {
        // Just moving it to the end is enough sometimes, or just href change is enough.
        // Let's stick to href change. If user reports issues, we can re-append.
        // document.head.append(link)
      }
    }
  })

  // Handle image load error (e.g. 404 or CORS) -> draw without background or use fallback
  img.addEventListener('error', () => {
    // Fallback: just draw the badge on empty canvas?
    // Or just ignore.
  })

  img.src = originalFavicon!
}

function startFaviconObserver() {
  if (faviconObserver) return

  faviconObserver = new MutationObserver((mutations) => {
    let shouldUpdate = false
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        // Check if any added node is a link icon
        for (const node of mutation.addedNodes) {
          if (node instanceof HTMLLinkElement && node.rel.includes('icon')) {
            // Ignore if it's the one we just generated
            if (node.href === lastGeneratedFavicon) continue
            shouldUpdate = true
          }
        }
      } else if (
        mutation.type === 'attributes' &&
        mutation.attributeName === 'href'
      ) {
        const target = mutation.target as HTMLLinkElement
        if (target.rel && target.rel.includes('icon')) {
          if (target.href === lastGeneratedFavicon) continue
          shouldUpdate = true
        }
      }
    }

    if (shouldUpdate) {
      updateFavicon(currentUnreadCount)
    }
  })

  faviconObserver.observe(document.head, {
    childList: true,
    attributes: true,
    attributeFilter: ['href'],
  })
}

const updateUtagsShortcuts = debounce(
  (count: number, getSettings: GetSettings): void => {
    const settings = getSettings()
    const displayCount = settings.checkUnreadNotificationsUtags ? count : 0

    const host = document.querySelector(
      '[data-ushortcuts-host="utags-shortcuts"]'
    )
    if (!host || !host.shadowRoot) return

    const links = host.shadowRoot.querySelectorAll('a')
    for (const link of links) {
      try {
        updateUtagsShortcutsLink(link, displayCount)
      } catch {}
    }
  },
  200
)

function updateUtagsShortcutsLink(
  link: HTMLAnchorElement,
  count: number
): void {
  const url = new URL(link.href)
  if (url.origin !== location.origin || url.pathname !== '/notifications')
    return

  const textSpan = link.querySelector<HTMLElement>('.title-text')
  if (!textSpan) return

  if (count > 0) {
    if (!textSpan.dataset.originalText) {
      textSpan.dataset.originalText = textSpan.textContent || '通知'
    }

    const newText = `${textSpan.dataset.originalText} (${count} 条未读)`
    if (textSpan.textContent !== newText) {
      textSpan.textContent = newText
    }

    if (textSpan.style.fontWeight !== 'bold') {
      textSpan.style.fontWeight = 'bold'
    }

    if (textSpan.style.color !== 'red') {
      textSpan.style.color = 'red'
    }
  } else if (textSpan.dataset.originalText) {
    if (textSpan.textContent !== textSpan.dataset.originalText) {
      textSpan.textContent = textSpan.dataset.originalText
    }

    delete textSpan.dataset.originalText
    if (textSpan.style.fontWeight !== '') {
      textSpan.style.fontWeight = ''
    }

    if (textSpan.style.color !== '') {
      textSpan.style.color = ''
    }
  }
}

function updateUI(count: number, getSettings: GetSettings): void {
  currentUnreadCount = count
  const settings = getSettings()

  const element = document.querySelector(
    '[data-right-sidebar="true"] .card-body a[href="/notifications"] > div'
  )
  if (element) {
    const newText = `${count} 条消息`
    const className = count > 0 ? 'text-primary' : ''
    if (element.textContent !== newText) {
      element.textContent = newText
    }

    if (element.className !== className) {
      element.className = className
    }
  }

  // Restore original favicon if setting is disabled
  const faviconCount = settings.checkUnreadNotificationsFavicon ? count : 0

  updateFavicon(faviconCount)

  updateUtagsShortcuts(count, getSettings)

  const title = document.title
  const prefixRegex = /^\(\d+\) /
  let newTitle = title
  if (settings.checkUnreadNotificationsTitle && count > 0) {
    const newPrefix = `(${count}) `
    newTitle = prefixRegex.test(title)
      ? title.replace(prefixRegex, newPrefix)
      : newPrefix + title
  } else {
    newTitle = title.replace(prefixRegex, '')
  }

  if (newTitle !== title) {
    document.title = newTitle
  }
}

export async function check(
  getSettings: GetSettings,
  force = false
): Promise<void> {
  const settings = getSettings()
  if (!settings.enabled || !settings.checkUnreadNotifications) return

  const now = Date.now()
  if (!force) {
    const lastCheck = (await getValue<number>(KEY_LAST_CHECK, 0))!
    if (now - lastCheck < CHECK_INTERVAL) return
  }

  const lockTime = (await getValue<number>(KEY_LOCK, 0))!
  if (now - lockTime < LOCK_TIMEOUT) return

  // Try acquire lock
  await setValue(KEY_LOCK, now)
  const currentLock = (await getValue<number>(KEY_LOCK, 0))!
  if (currentLock !== now) return

  try {
    const count = await fetchUnreadCount()
    if (count !== undefined) {
      await setValue(KEY_UNREAD_COUNT, count)
      await setValue(KEY_LAST_CHECK, Date.now())
    }
  } finally {
    await setValue(KEY_LOCK, 0)
  }
}

export function initCheckNotifications(getSettings: GetSettings): void {
  if (initialized) return
  initialized = true

  startUtagsObserver(getSettings)
  startFaviconObserver()

  // Listen for changes
  void addValueChangeListener(KEY_UNREAD_COUNT, (_key, _old, newValue) => {
    if (typeof newValue === 'number') {
      updateUI(newValue, getSettings)
    }
  })

  // Initial check of stored value to update UI immediately
  void (async () => {
    const value = await getValue<number>(KEY_UNREAD_COUNT)
    if (typeof value === 'number') {
      updateUI(value, getSettings)
    }
  })()

  // Loop
  setInterval(() => {
    void check(getSettings)
  }, 10 * 1000)

  // Run once immediately
  void check(getSettings)
}

export function runCheckNotifications(getSettings: GetSettings): void {
  void check(getSettings)
  void (async () => {
    const value = await getValue<number>(KEY_UNREAD_COUNT)
    if (typeof value === 'number') {
      updateUI(value, getSettings)
    }
  })()
}
